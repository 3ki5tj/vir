Computing the virial coefficients by Monte Carlo sampling
==========================================================


Files
-----
mcrat0.c    calculate the virial coefficients
            Ree-Hoover star contents are used, so no need to sample
            over diagrams

mcstat.c    compute some statisitics of the diagrams

mcgc2.c     grand canonical simulation
            no intermediate states, but uses heat-bath algorithm
            (see Tips)

mcgcr2.c    grand canonical simulation, multiple intermediate states
            with a distance restraint between a pair of special vertices
            heat-bath algorithm
            (see Tips)



bak: old programs
~~~~~~~~~~~~~~~~~~~
dgcnt.c     count the number of the biconnected diagrams

dgmc.c      calculate the virial coefficients by Monte Carlo sampling
            this program directly samples over diagrams without using
            the Ree-Hoover star contents. So it is not very efficient

mcrepl.c    coordinate replacement as a Monte Carlo move

mcrat.c     sampling biconnected configurations, coupled with a sampler
            that samples configurations without clique separators and an
            importance sampler that samples configurations for fb

mcratn.c    sampling along the number of clique separators

mcwt.c      prototype code for mcrat.c sampling in three ensembles
            biconnected, nonzero fb, and importance sampling

mcnz.c      prototype code for sampling in two ensembles
            biconnected and nonzero fb

mcgcx.c     supposed to be a better version than mcgcr.c
            involves a scaling of diagrams
            developed before mcgcr.c

mcgcr.v1.c  Metropolis and heat-bath algorithms for mcgcr
mcgcr2.v1.c very few differences

mcrat0L.c   a variant of mcrat0.c for the larger lookup table (dgmapl.h)



Monte Carlo sampling
---------------------

The conventional formula for the nth order virial coefficient is

  vir = (1 - n)/n! v0^(n - 1) sum_g acc_g s_g.                        (1)

where v0 = 4 pi/3 is the volume of the unit ball, such that v0^(n - 1)
      is the reference integral of the spanning tree.
      The sum is over all diagrams `g'.
      s_g = (-1)^e_g, where `e_g' is the number of edges in the diagram `g'
      `acc_g' is ratio of the integral of the diagram `g' to
      that of the spanning tree.  In the MC integration acc_g = n_g / nt,
      where `n_g' is the number of accepted points,
      `nt' is the number total points.


In MC sampling, we can compute the fraction of ring diagrams

  r_r   = (n_r / sum_g n_g) * mul_r,                          (2)

where mul_r = n! / (2 n),  where 2n is the symmetry number
(n clockwise and counter-clockwise rotations).
The virial rate is

  r_vir = sum_g n_g s_g / sum_g n_g,                          (3)

So (2)/(3) gives

    r_r / r_vir = mul_r * sum_g n_g s_g / n_r
  = mul_r sum_g acc_g s_g / acc_r                             (4)

Plugging (4) into (1) yields

  vir = (1 - n) / (2n) v0^(n - 1) acc_r * r_r / r_vir.        (5)



Usage mcrat0
---------------------------

Versions
~~~~~~~~~

Use
  gcc -fopenmp
or
  icc -openmp
to compile the thread version

Use
  mpicc -DMPI
to compile the MPI version

Use
  icc -mmic -openmp
to compile the Intel MIC version

The dimension D needs to specified during compilation, e.g.,
  -DD=20
by default D=3





Methods of computing the hard-sphere weights
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For n <= 8, we use the regular lookup table (command line option -L1).
For n > 9, we use the direct branch (-L0).
For n == 9, we use the larger lookup table,
  which is included in the direct branch (-L0).
To test the larger lookup table for n <=8, use -L0.




Benchmark of mcrat0
---------------------------

Regular lookup table
~~~~~~~~~~~~~~~~~~~~~
D = 3, n = 7, -1 1e9 -0 1e6, vir = 0.0130228
negligible memory requirement
T60:  single thread:            2m41s/2m40                  icc -DD=3 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                3m52s/3m49                  gcc -DD=3 -O2 -ipo mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -9 1e6
      two threads openmp:       4m21s/7m35s                 icc -DD=3 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                5m17s/9m6s                  gcc -DD=3 -fopenmp -O2 -march=native mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -0 1e6

Larger lookup table 
~~~~~~~~~~~~~~~~~~~~~
D = 2, n = 9, -1 1e8 -0 1e6, vir = 0.0362202
require at least 1G memory
T60:  single thread:            2m19s/2m16                  icc -DD=2 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e8 -0 1e6
                                2m16s/2m13                  gcc -DD=2 -O2 -ipo mcrat0.c -lm && time ./a.out -n 9 -1 1e8 -9 1e6
      two threads openmp:       2m43s/4m45s                 icc -DD=2 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e8 -0 1e6
                                2m36s/4m11s                 gcc -DD=2 -fopenmp -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e8 -0 1e6
      (no MPI version for it requires at least 2G memory)

D = 2, n = 9, -1 1e9 -0 1e6, vir = 0.0362202
ipo:  single thread:            7m26s                       icc -DD=2 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6
                                6m39s                       gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e9 -0 1e6
      single thread (-k 7):     5m54s                       icc -DD=2 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
                                5m42s                       gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
      8-thread openmp:          1m9s
                                10m8s (-1 1e9)
                                11m7s (single-if)
      32-thread openmp:         12m35s/45m25s (double-if)
      MPI/gcc, mpirun -np 8:    9m33s (-1 1e9)

 
Direct method
~~~~~~~~~~~~~~~~~~~~~







Usage of mcgc and mcgcr2
---------------------------

* The files need to compiled for each dimension.  It is recommended to compile
  each source before each run.  For example

  mpicc -DMPI=1 -DD=20 -DNMAX=64 mcgc2.c && mpirun -np 4 ./a.out -o a.dat

  which computes the first 64 virial coefficients for D = 20, or

  mpicc -DMPI=1 -DD=50 mcgcr2.c && mpirun -np 4 ./a.out -n 8 -o a.dat -m 3 -c 0.4

  which computes the first 8 virial coefficients for D = 50


* -DD=20 works for the 20 dimensional problem.

* -DNMAX=64 if the maximal order is greater than 64.

* -DMPI=1 if an MPI version is needed

* In the parameters-adjusting runs, run with -E 10 (or any number) and -0 1e6 (or something larger).
  Do not run the MPI version.

* In the first production run, use the switch -R -B or -RB.
  This will clear the data in the previous file.
  But on output, no parameters are updated.
  The same effect can be achieved by runing with -R, but
  add ``dirty'' (remove the quotes) in the information line
  of the input file `Zr[hr]D***.dat'

* In successive production runs, use the switch -R (restartable)
  The data in the previous will be loaded.
  Parameters are not altered on output.



Git branches
----------------
master

gcr2:  development of mcgcr2

ring:  development of the ring content in dgring.h and its application

singleif:
doubleif:  development of the OpenMP version, the doubleif version is better
           It appears that the double-if branch is faster b/c it voids creating too
           many `omp critical' blocks (mutexes).

mpi_openmp: MPI + OpenMP version, intended for two MIC cards on stampede
            this branch is unsuccessful, and may be deleted in the future
