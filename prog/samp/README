Computing the virial coefficients by Monte Carlo sampling
==========================================================


Files
-----
mcrat0.c    calculate the virial coefficients
            Ree-Hoover star contents are used, so no need to sample
            over diagrams

mcstat.c    compute some statisitics of the diagrams

mcgc2.c     grand canonical simulation
            no intermediate states, but uses heat-bath algorithm
            (see Tips)

mcgcr2.c    grand canonical simulation, multiple intermediate states
            with a distance restraint between a pair of special vertices
            heat-bath algorithm
            (see Tips)



bak: old programs
~~~~~~~~~~~~~~~~~~~
dgcnt.c     count the number of the biconnected diagrams

dgmc.c      calculate the virial coefficients by Monte Carlo sampling
            this program directly samples over diagrams without using
            the Ree-Hoover star contents. So it is not very efficient

mcrepl.c    coordinate replacement as a Monte Carlo move

mcrat.c     sampling biconnected configurations, coupled with a sampler
            that samples configurations without clique separators and an
            importance sampler that samples configurations for fb

mcratn.c    sampling along the number of clique separators

mcwt.c      prototype code for mcrat.c sampling in three ensembles
            biconnected, nonzero fb, and importance sampling

mcnz.c      prototype code for sampling in two ensembles
            biconnected and nonzero fb

mcgcx.c     supposed to be a better version than mcgcr.c
            involves a scaling of diagrams
            developed before mcgcr.c

mcgcr.v1.c  Metropolis and heat-bath algorithms for mcgcr
mcgcr2.v1.c very few differences

mcrat0L.c   a variant of mcrat0.c for the larger lookup table (dgmapl.h)



Monte Carlo sampling
---------------------

The conventional formula for the nth order virial coefficient is

  vir = (1 - n)/n! v0^(n - 1) sum_g acc_g s_g.                        (1)

where v0 = 4 pi/3 is the volume of the unit ball, such that v0^(n - 1)
      is the reference integral of the spanning tree.
      The sum is over all diagrams `g'.
      s_g = (-1)^e_g, where `e_g' is the number of edges in the diagram `g'
      `acc_g' is ratio of the integral of the diagram `g' to
      that of the spanning tree.  In the MC integration acc_g = n_g / nt,
      where `n_g' is the number of accepted points,
      `nt' is the number total points.


In MC sampling, we can compute the fraction of ring diagrams

  r_r   = (n_r / sum_g n_g) * mul_r,                          (2)

where mul_r = n! / (2 n),  where 2n is the symmetry number
(n clockwise and counter-clockwise rotations).
The virial rate is

  r_vir = sum_g n_g s_g / sum_g n_g,                          (3)

So (2)/(3) gives

    r_r / r_vir = mul_r * sum_g n_g s_g / n_r
  = mul_r sum_g acc_g s_g / acc_r                             (4)

Plugging (4) into (1) yields

  vir = (1 - n) / (2n) v0^(n - 1) acc_r * r_r / r_vir.        (5)



Usage mcrat0
---------------------------

Versions
~~~~~~~~~

Use
  gcc -fopenmp
or
  icc -openmp
to compile the thread version

Use
  mpicc -DMPI
to compile the MPI version

Use
  icc -mmic -openmp
to compile the Intel MIC version

The dimension D needs to specified during compilation, e.g.,
  -DD=20
by default D=3

When the hash table is used, defining the order in advance can save memory
  -DN=12




Methods of computing the hard-sphere weights
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For n <= 8, we use the regular lookup table (command line option -L1).
For n > 9, we use the direct branch (-L0).
For n == 9, we use the larger lookup table,
  which is included in the direct branch (-L0).
To test the larger lookup table for n <=8, use -L0.




Benchmark of mcrat0
---------------------------

Note, pinning threads can be helpful.
icc:
  export KMP_AFFINITY=scatter
  export KMP_AFFINITY="proclist=[0,1],explicit"

gcc:
  GOMP_CPU_AFFINITY="0-1" ./a.out

Conclusions:
* use -O3 and GOMP_CPU_AFFINITY for gcc
* KMP_AFFINITY is less useful

Regular lookup table
~~~~~~~~~~~~~~~~~~~~~
D = 3, n = 7, -1 1e9 -0 1e6, vir = 0.0130228
negligible memory requirement
T60:  single thread:            2m41s/2m40s, 2m38s/2m36s    icc -DD=3 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                3m52s/3m49s, 3m57s/3m54s    gcc -DD=3 -O2 -march=native mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -0 1e6
      two threads openmp:       4m21s/7m35s, 4m14s/7m37s    icc -DD=3 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                4m7s/7m29s                  gcc -DD=3 -fopenmp -O2 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-1" ./a.out -n 7 -1 1e9 -0 1e6
                                3m43s/6m15s                 gcc -DD=3 -fopenmp -O3 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-1" ./a.out -n 7 -1 1e9 -0 1e6
      MPI/gcc -np 2:            5m13s/9m29s, 5m53s/10m5s    mpicc -DMPI -DD=3 -O2 -march=native mcrat0.c && rm -f mr* && time mpirun -np 2 ./a.out -n 7 -1 1e9 -0 1e6
                                4m45s/8m30s                 mpicc -DMPI -DD=3 -O3 -march=native mcrat0.c && rm -f mr* && time mpirun -np 2 ./a.out -n 7 -1 1e9 -0 1e6

ipo:  single thread:            58s                         icc -DD=3 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                1m21s                       gcc -DD=3 -O2 -march=native mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -0 1e6
                                1m3s                        gcc -DD=3 -O3 -march=native mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -0 1e6
      8 threads openmp:         2m35s/20m35s, 2m34/20m28s   icc -DD=3 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                2m10s/17m23s                gcc -DD=3 -fopenmp -O2 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-7" ./a.out -n 7 -1 1e9 -0 1e6
                                1m45s/13m57s                gcc -DD=3 -fopenmp -O3 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-7" ./a.out -n 7 -1 1e9 -0 1e6
      two threads openmp:       1m24/2m47                   icc -DD=3 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 7 -1 1e9 -0 1e6
                                1m22s/2m44s                 gcc -DD=3 -fopenmp -O2 -march=native mcrat0.c -lm && time ./a.out -n 7 -1 1e9 -0 1e6
                                1m2s/2m3s                   gcc -DD=3 -fopenmp -O3 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-1" ./a.out -n 7 -1 1e9 -0 1e6
      MPI/gcc -np 8:            2m16s/16m5s                 mpicc -DMPI -DD=3 -O3 -march=native mcrat0.c && rm -f mr* && time mpirun -np 8 ./a.out -n 7 -1 1e9 -0 1e6
      MPI/gcc -np 2:            1m7s/2m11s                  mpicc -DMPI -DD=3 -O3 -march=native mcrat0.c && rm -f mr* && time mpirun -np 2 ./a.out -n 7 -1 1e9 -0 1e6

Note the 8 threads on ipo are actually produced by hyperthreads.  There are only four real threads.

mic (1e8 steps for each thread):
60 threads 2m20s
61 threads 2m27s
240 threads 5m24s
244 threads 5m12s
120 threads 2m59s

Larger lookup table
~~~~~~~~~~~~~~~~~~~~~
D = 2, n = 9, -1 1e8 -0 1e6, vir = 0.0362202
require at least 1G memory
T60:  single thread:            2m19s/2m16                  icc -DD=2 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e8 -0 1e6
                                2m16s/2m13                  gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e8 -0 1e6
      two threads openmp:       2m43s/4m45s                 icc -DD=2 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e8 -0 1e6
                                2m36s/4m11s                 gcc -DD=2 -fopenmp -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e8 -0 1e6
      (no MPI version for it requires at least 2G memory)


D = 2, n = 9, -1 1e9 -0 1e6, vir = 0.0362202
(note: dropping -march=native improves efficiency, in the single-core case)
ipo:  single thread:            6m42s                       icc -DD=2 -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6
                                6m39s, 7m2s                 gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e9 -0 1e6
      single thread (-k 7):     5m33s                       icc -DD=2 -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
                                5m42s                       gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
      8-thread openmp (-k 8):   12m21s/88m36s               icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 8
                                11m11s/80m58s               icc -DD=2 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 8
                                8m43s/69m28s                gcc -DD=2 -fopenmp -O3 -march=native mcrat0.c && time GOMP_CPU_AFFINITY="0-7" ./a.out -n 9 -1 1e9 -0 1e6 -k 7
      8-thread openmp (-k 7):   8m8s/64m53s                 icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
                                7m8s/56m56s                 gcc -DD=2 -fopenmp -O3 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-7" ./a.out -n 9 -1 1e9 -0 1e6 -k 7
      2-thread openmp (-k 7):   5m45s/11m29s                icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 1e9 -0 1e6 -k 7
                                5m5s/10m9s                  gcc -DD=2 -fopenmp -O3 -march=native mcrat0.c -lm && time GOMP_CPU_AFFINITY="0-1" ./a.out -n 9 -1 1e9 -0 1e6 -k 7
      MPI/gcc, -np 8:           9m33s


D = 2, n = 9, -1 2e9 -0 1e6, vir = 0.0362202, increased simulation length
ipo:
      2-thread openmp (-k 7):   11m2s/22m1s                 icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 2e9 -0 1e6 -k 7

D = 3, n = 9, -1 2e9 -0 1e6, vir = 0.0362202
ipo:
      2-thread openmp (-k 7):   11m27s/22m48s               icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 2e9 -0 1e6 -k 7

D = 4, n = 9, -1 2e9 -0 1e6, vir = 0.0362202
ipo:
      2-thread openmp (-k 7):   10m56s/21m48s               icc -DD=2 -openmp -O2 -ipo mcrat0.c && time ./a.out -n 9 -1 2e9 -0 1e6 -k 7



Hash table
~~~~~~~~~~~~~~~~~~~~~
Note for simulations with "level 1", the starred(*) versions have --hash-isoenum turned on by default
Note also that some version without --stat runs faster

D = 2, n = 9, -1 1e8 -0 1e6 -w 1, vir = 0.0362202
T60:  single thread (level 9):  2m37s/2m38s                 icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      single thread (level 1):  2m05s/2m04s                 icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *single thread (level 1):  1m16s/1m16s                 icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
      2-thread (level 9):       3m42s/7m05s                 icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e8 --hash-mode=1 --auto-level=9
     *2-thread (level 1):       1m20s/2m34s                 icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e8 --hash-mode=1 --auto-level=1

D = 2, n = 9, -1 1e9 -0 1e6 -w 1, vir = 0.0362202
ipo:  single thread (level 9):  12m00s/12m00s               icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      single thread (level 1):   6m22s/ 6m22s               icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *single thread (level 1):   5m20s/ 5m20s               icc -DD=2 -DN=9 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
      2-thread (level 4):       15m31s/30m51s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=4
      2-thread (level 4, 2e9):  31m02s/62m02s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=4
      2-thread (level 3, 2e9):  18m40s/37m16s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=3
      2-thread (level 2, 2e9):  17m31s/35m00s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=2
      2-thread (level 1):        7m07s/14m12s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *2-thread (level 1):        6m32s/13m2s                icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
      2-thread (level 1, 2e9):  13m07s/26m08s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *2-thread (level 1, 2e9):  12m45s/25m23s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
      2-thread (level 1, 4e9):  26m23s/52m28s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 4e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
                                24m27s/48m43s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 4e9 -0 1e6 --hash-mode=1 --auto-level=1
     *4-thread (level 1):        6m39s/26m27s               icc -DD=2 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=4 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1

In conclusion, in D = 2, n = 9, with auto_level = 1, hash_isoenum = 1,
  the hash table performs as well as mapl.


D = 3, n = 9, -1 1e8 -0 1e6 -w 1, vir = 1.310e-3
T60
     *2-thread (level 1):        1m27s/ 2m49s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e8 -0 1e6 --hash-mode=1 --auto-level=1

D = 3, n = 9, -1 1e9 -0 1e6 -w 1, vir = 1.310e-3
ipo:
      2-thread (level 9):       12m50s/25m35s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      2-thread (level 9, 2e9):  25m24s/50m40s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      2-thread (level 1):        8m06s/16m12s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *2-thread (level 1):        6m20s/12m37s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
      2-thread (level 1, 2e9):  15m07s/30m12s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=20 --stat --auto-level=1
      2-thread (level 1, 4e9):  29m56s/59m42s               icc -DD=3 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 4e9 -0 1e6 --hash-mode=1 --hash-bits=20 --auto-level=1

D = 4, n = 9, -1 1e8 -0 1e6 -w 1, vir = 1.310e-3
T60
     *2-thread (level 1):        1m45s/ 3m19s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1

D = 4, n = 9, -1 2e9 -0 1e6 -w 1, vir =
ipo:
      2-thread (level 9):       22m29s/44m57s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=20 --stat --auto-level=9
      2-thread (level 1):       14m48s/29m34s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=20 --stat --auto-level=1
      2-thread (level 1, 1e9):   5m55s/11m47s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=24 --stat --auto-level=1

D = 5, n = 9, -1 2e9 -0 1e6 -w 1, vir =
ipo:
      2-thread (level 9):       22m29s/44m57s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=20 --stat --auto-level=9
      2-thread (level 1):       14m11s/28m19s               icc -DD=4 -DN=9 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --hash-bits=20 --stat --auto-level=1



D = 2, n = 10, -1 1e8 -0 1e6 -w 1, vir = 0.019953
T60:
      single thread (level 9):  5m50s/5m42s                 icc -DD=2 -DN=10 -openmp -O2 -march=native -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e8 -0 1e6 --hash-mode=1
     *2-thread (level 1):       5m03s/9m33s                 icc -DD=2 -DN=10 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e8 -0 1e6 --hash-mode=1 --auto-level=1

D = 2, n = 10, -1 1e9 -0 1e6 -w 1, vir = 0.019953
ipo:  single thread (level 9):  15m30s/15m30s               icc -DD=2 -DN=10 -O2 -ipo mcrat0.c && rm -f mr* && time ./a.out -1 1e9 -0 1e6 --hash-mode=1
      2-thread (level 9):       18m00s/36m00s               icc -DD=2 -DN=10 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      2-thread (level 9, 2e9):  36m07s/72m06s               icc -DD=2 -DN=10 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --stat --auto-level=9
      2-thread (level 1):       18m18s/36m34s               icc -DD=2 -DN=10 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1
     *2-thread (level 1):        9m58s/19m46s               icc -DD=2 -DN=10 -openmp -O2 -ipo mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 1e9 -0 1e6 --hash-mode=1 --stat --auto-level=1 --hash-memmax=1e10

D = 3, n = 10, -1 2e9 -0 1e6 -w 1, vir
ipo:
      2-thread (level 9):       29m07s/58m11s               icc -DD=3 -DN=10 -O2 -ipo -openmp mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --auto-level=9 --hash-bits=23
     *2-thread (level 1, 2e9):  20m20s/40m11s               icc -DD=3 -DN=10 -O2 -ipo -openmp mcrat0.c && rm -f mr* && time OMP_NUM_THREADS=2 ./a.out -1 2e9 -0 1e6 --hash-mode=1 --auto-level=1 --hash-bits=25 --hash-memmax=14e9


D = 4, n = 10, -1 1e9 -0 1e6 -w 1, vir
ipo:
      2-thread (level 9):       14m41s/29m18s               icc -DD=4 -DN=10 -O2 -ipo -openmp mcrat0.c && rm mr* -f && time OMP_NUM_THREADS=2 ./a.out -1 1e9 --hash-mode=1 --auto-level=9 --hash-memmax=6e9  --hash-bits=23 --hash-initls=1
     *2-thread (level 1):       17m25s/34m47s               icc -DD=4 -DN=10 -O2 -ipo -openmp mcrat0.c && rm mr* -f && time OMP_NUM_THREADS=2 ./a.out -1 1e9 --hash-mode=1 --auto-level=1 --hash-memmax=6e9  --hash-bits=26 --hash-initls=1
     *2-thread (level 1):       12m34s/24m33s               icc -DD=4 -DN=10 -O2 -ipo -openmp mcrat0.c && rm mr* -f && time OMP_NUM_THREADS=2 ./a.out -1 2e9 --hash-mode=1 --auto-level=1 --hash-memmax=14e9 --hash-bits=26 --hash-initls=1
Note the memory limit in the second run.



Direct method
~~~~~~~~~~~~~~~~~~~~~
D = 2, n = 10, -1 1e8 -0 1e6 -w 10, vir = 0.019953

T60:  single thread:            9m44s/9m37                  icc -DD=2 -O2 -march=native -ipo mcrat0.c && time ./a.out -n 10 -1 1e8 -0 1e6 --hash-mode=0
                                9m05s/8m58                  gcc -DD=2 -O2 -march=native mcrat0.c -lm && time ./a.out -n 10 -1 1e8 -9 1e6 --hash-mode=0
      two threads openmp:       14m9s/22m54s                icc -DD=2 -openmp -O2 -march=native -ipo mcrat0.c && time ./a.out -n 10 -1 1e8 -0 1e6 --hash-mode=0
                                13m2s/21m35s                gcc -DD=2 -fopenmp -O2 -march=native mcrat0.c -lm && time ./a.out -n 10 -1 1e8 -0 1e6 --hash-mode=0
      MPI/gcc -np 8:            13m16s/22m12s               mpicc -DD=2 -O2 -march=native mcrat0.c -lm && rm -f mr* && time mpirun -np 2 ./a.out -n 10 -1 1e8 -0 1e6 --hash-mode=0






Usage of mcgc and mcgcr2
---------------------------

* The files need to compiled for each dimension.  It is recommended to compile
  each source before each run.  For example

  mpicc -DMPI=1 -DD=20 -DNMAX=64 mcgc2.c && mpirun -np 4 ./a.out -o a.dat

  which computes the first 64 virial coefficients for D = 20, or

  mpicc -DMPI=1 -DD=50 mcgcr2.c && mpirun -np 4 ./a.out -n 8 -o a.dat -m 3 -c 0.4

  which computes the first 8 virial coefficients for D = 50


* -DD=20 works for the 20 dimensional problem.

* -DNMAX=64 if the maximal order is greater than 64.

* -DMPI=1 if an MPI version is needed

* In the parameters-adjusting runs, run with -E 10 (or any number) and -0 1e6 (or something larger).
  Do not run the MPI version.

* In the first production run, use the switch -R -B or -RB.
  This will clear the data in the previous file.
  But on output, no parameters are updated.
  The same effect can be achieved by runing with -R, but
  add ``dirty'' (remove the quotes) in the information line
  of the input file `Zr[hr]D***.dat'

* In successive production runs, use the switch -R (restartable)
  The data in the previous will be loaded.
  Parameters are not altered on output.



Git branches
----------------
master

gcr2:  development of mcgcr2

ring:  development of the ring content in dgring.h and its application

singleif:
doubleif:  development of the OpenMP version, the doubleif version is better
           It appears that the double-if branch is faster b/c it voids creating too
           many `omp critical' blocks (mutexes).

mpi_openmp: MPI + OpenMP version, intended for two MIC cards on stampede
            this branch is unsuccessful, and may be deleted in the future
