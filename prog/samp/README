Computing the virial coefficients by Monte Carlo sampling
==========================================================


Files
-----
mcrat.c     calculate the ratio of two successive virial coefficients
            Ree-Hoover star contents are used, so no need to sample
            over diagrams

mcstat.c    compute some statisitics of the diagrams

mcgc2.c     grand canonical simulation
            no intermediate states, but uses heat-bath algorithm
            (see Tips)

mcgcr2.c    grand canonical simulation, multiple intermediate states
            with a distance restraint between a pair of special vertices
            heat-bath algorithm
            (see Tips)



bak: old programs
~~~~~~~~~~~~~~~~~~~
dgcnt.c     count the number of the biconnected diagrams

dgmc.c      calculate the virial coefficients by Monte Carlo sampling
            this program directly samples over diagrams without using
            the Ree-Hoover star contents. So it is not very efficient

mcrepl.c    coordinate replacement as a Monte Carlo move

mcratn.c    sampling along the number of clique separators

mcwt.c      prototype code for sampling in three ensembles
            biconnected, nonzero fb, and importance sampling

mcnz.c      prototype code for sampling in two ensembles
            biconnected and nonzero fb

mcgcx.c     supposed to be a better version than mcgcr.c
            involves a scaling of diagrams
            developed before mcgcr.c

mcgcr.v1.c  Metropolis and heat-bath algorithms for mcgcr
mcgcr2.v1.c very few differences



Monte Carlo sampling
---------------------

The conventional formula for the nth order virial coefficient is

  vir = (1 - n)/n! v0^(n - 1) sum_g acc_g s_g.                        (1)

where v0 = 4 pi/3 is the volume of the unit ball, such that v0^(n - 1)
      is the reference integral of the spanning tree.
      The sum is over all diagrams `g'.
      s_g = (-1)^e_g, where `e_g' is the number of edges in the diagram `g'
      `acc_g' is ratio of the integral of the diagram `g' to
      that of the spanning tree.  In the MC integration acc_g = n_g / nt,
      where `n_g' is the number of accepted points,
      `nt' is the number total points.


In MC sampling, we can compute the fraction of ring diagrams

  r_r   = (n_r / sum_g n_g) * mul_r,                          (2)

where mul_r = n! / (2 n),  where 2n is the symmetry number
(n clockwise and counter-clockwise rotations).
The virial rate is

  r_vir = sum_g n_g s_g / sum_g n_g,                          (3)

So (2)/(3) gives

    r_r / r_vir = mul_r * sum_g n_g s_g / n_r
  = mul_r sum_g acc_g s_g / acc_r                             (4)

Plugging (4) into (1) yields

  vir = (1 - n) / (2n) v0^(n - 1) acc_r * r_r / r_vir.        (5)






Usage of mcgc and mcgcr2
---------------------------

* The files need to compiled for each dimension.  It is recommended to compile
  each source before each run.  For example

  mpicc -DMPI=1 -DD=20 -DNMAX=64 mcgc2.c && mpirun -np 4 ./a.out -o a.dat

  which computes the first 64 virial coefficients for D = 20, or

  mpicc -DMPI=1 -DD=50 mcgcr2.c && mpirun -np 4 ./a.out -n 8 -o a.dat -m 3 -c 0.4

  which computes the first 8 virial coefficients for D = 50


* -DD=20 works for the 20 dimensional problem.

* -DNMAX=64 if the maximal order is greater than 64.

* -DMPI=1 if an MPI version is needed

* In the parameters-adjusting runs, run with -E 10 (or any number) and -0 1e6 (or something larger).
  Do not run the MPI version.

* In the first production run, use the switch -R -B or -RB.
  This will clear the data in the previous file.
  But on output, no parameters are updated.
  The same effect can be achieved by runing with -R, but
  add ``dirty'' (remove the quotes) in the information line
  of the input file `Zr[hr]D***.dat'

* In successive production runs, use the switch -R (restartable)
  The data in the previous will be loaded.
  Parameters are not altered on output.




