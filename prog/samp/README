Computing the virial coefficients by Monte Carlo sampling
==========================================================


Files
-----
mcrat0.c    calculate the virial coefficients
            Ree-Hoover star contents are used, so no need to sample
            over diagrams

mcstat.c    compute some statisitics of the diagrams

mcgc2.c     grand canonical simulation
            no intermediate states, but uses heat-bath algorithm
            (see Tips)

mcgcr2.c    grand canonical simulation, multiple intermediate states
            with a distance restraint between a pair of special vertices
            heat-bath algorithm
            (see Tips)



bak: old programs
~~~~~~~~~~~~~~~~~~~
dgcnt.c     count the number of the biconnected diagrams

dgmc.c      calculate the virial coefficients by Monte Carlo sampling
            this program directly samples over diagrams without using
            the Ree-Hoover star contents. So it is not very efficient

mcrepl.c    coordinate replacement as a Monte Carlo move

mcrat.c     sampling biconnected configurations, coupled with a sampler
            that samples configurations without clique separators and an
            importance sampler that samples configurations for fb

mcratn.c    sampling along the number of clique separators

mcwt.c      prototype code for mcrat.c sampling in three ensembles
            biconnected, nonzero fb, and importance sampling

mcnz.c      prototype code for sampling in two ensembles
            biconnected and nonzero fb

mcgcx.c     supposed to be a better version than mcgcr.c
            involves a scaling of diagrams
            developed before mcgcr.c

mcgcr.v1.c  Metropolis and heat-bath algorithms for mcgcr
mcgcr2.v1.c very few differences



Monte Carlo sampling
---------------------

The conventional formula for the nth order virial coefficient is

  vir = (1 - n)/n! v0^(n - 1) sum_g acc_g s_g.                        (1)

where v0 = 4 pi/3 is the volume of the unit ball, such that v0^(n - 1)
      is the reference integral of the spanning tree.
      The sum is over all diagrams `g'.
      s_g = (-1)^e_g, where `e_g' is the number of edges in the diagram `g'
      `acc_g' is ratio of the integral of the diagram `g' to
      that of the spanning tree.  In the MC integration acc_g = n_g / nt,
      where `n_g' is the number of accepted points,
      `nt' is the number total points.


In MC sampling, we can compute the fraction of ring diagrams

  r_r   = (n_r / sum_g n_g) * mul_r,                          (2)

where mul_r = n! / (2 n),  where 2n is the symmetry number
(n clockwise and counter-clockwise rotations).
The virial rate is

  r_vir = sum_g n_g s_g / sum_g n_g,                          (3)

So (2)/(3) gives

    r_r / r_vir = mul_r * sum_g n_g s_g / n_r
  = mul_r sum_g acc_g s_g / acc_r                             (4)

Plugging (4) into (1) yields

  vir = (1 - n) / (2n) v0^(n - 1) acc_r * r_r / r_vir.        (5)



Usage mcrat0
---------------------------

Versions
~~~~~~~~~

Use
  gcc -fopenmp
or
  icc -openmp
to compile the thread version

Use
  mpicc -DMPI
to compile the MPI version

Use
  icc -mmic -openmp
to compile the Intel MIC version

The dimension D needs to specified during compilation, e.g.,
  -DD=20
by default D=3





Methods of computing the hard-sphere weights
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For n <= 8, we use the regular lookup table (command line option -L1).
For n > 9, we use the direct branch (-L0).
For n == 9, we use the larger lookup table,
  which is included in the direct branch (-L0).
To test the larger lookup table for n <=8, use -L0.




Benchmark of mcrat0
---------------------------


* Larger lookup map
-DD=2 -n 9 -1 1e8 -0 1e6
require 1G memory

T60: single thread:             3min
     two threads openmp:        3min40s/6m5s 

ipo: single thread:             56s
     8-thread openmp:           1m9s            10m8s  (-1 1e9) or 11m7s (single-if version) 
     32-thread openmp:          12m35s/45m25s
     MPI/gcc, mpirun -np 8:     1m21s           9m33s (-1 1e9)
     MPI/gcc, mpirun -np 1:     55s             6m35s (-1 1e9)
     

NOTES
~~~~~
There are two sub-branches, single-if and double-if under the branch openmp.
It appears that the double-if branch is faster b/c it voids creating too
many `omp critical' blocks (mutexes).






Usage of mcgc and mcgcr2
---------------------------

* The files need to compiled for each dimension.  It is recommended to compile
  each source before each run.  For example

  mpicc -DMPI=1 -DD=20 -DNMAX=64 mcgc2.c && mpirun -np 4 ./a.out -o a.dat

  which computes the first 64 virial coefficients for D = 20, or

  mpicc -DMPI=1 -DD=50 mcgcr2.c && mpirun -np 4 ./a.out -n 8 -o a.dat -m 3 -c 0.4

  which computes the first 8 virial coefficients for D = 50


* -DD=20 works for the 20 dimensional problem.

* -DNMAX=64 if the maximal order is greater than 64.

* -DMPI=1 if an MPI version is needed

* In the parameters-adjusting runs, run with -E 10 (or any number) and -0 1e6 (or something larger).
  Do not run the MPI version.

* In the first production run, use the switch -R -B or -RB.
  This will clear the data in the previous file.
  But on output, no parameters are updated.
  The same effect can be achieved by runing with -R, but
  add ``dirty'' (remove the quotes) in the information line
  of the input file `Zr[hr]D***.dat'

* In successive production runs, use the switch -R (restartable)
  The data in the previous will be loaded.
  Parameters are not altered on output.




