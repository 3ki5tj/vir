Compute virial coefficients from integral equations



Summary of programs
====================


"~" means non-essential files

C programs (native datatypes family)
-------------------------------------
    iegsl.c         GSL         an arbitrary even or odd dimension
                    slowdht.h

 ~  ie3dfftw.c      FFTW3       3-dimensional case
                    fft.h       -DNOFFTW
    ieodfftw.c      FFTW3       arbitrary odd-dimensional case
                    fft.h       -DNOFFTW

    ljie3dfftw.c    FFTW3       3-dimensional case for the LJ potential

    ieutil.h        none        common routines for the above programs

    xdouble.h       none        defines the datatype xdouble, which can be
                                double, long double or __float128.

    slowdht.h       GSL         discrete Hankel transform
                                (supports xdouble.h)

 ~  fft.h           none        home-made code for FFT
                                (supports xdouble.h, used as a reference)

C programs (MPFR family)
-------------------------
 ~  ie3dmpfr.c      MPFR        3-dimensional case
    ieodmpfr.c      MPFR        generalized odd-dimensional case

    ieutilmpfr.h    MPFR        common routines for the MPFR programs
                                the counterpart of ieutil.h

    fftmpfr.h       MPFR        multiple-precision code for FFT
                                the counterpart of fft.h

C programs (common)
--------------------
    zcom.h          none        common routines


Python script
--------------
    ievirextra.py               extrapolation script

    scifmt.py                   format a number with error in parentheses.


See bak/README for additional code.
ie3dxxx.c is kept along with ieodxxx.c for the purpose of double checking.




iegsl
======

Overview
---------

  o Designed for even dimension calculations, for odd dimensions,
    use ieodfftw or ieodmpfr instead.

  o Uses the discrete Hankel transform (based on the routine in the GSL library,
    but modified in slowdht.h)

  o Supports double/long double/__float128 as the basic data type.

  o slowdht.h permits disk-based Hankel transformation
    of many evaluation points

  o Supports check points, (with option "-s")
    which allows a restartable run.



Source code
------------
  o iegsl.c
  o slowdht.h
  o xdouble.h
  o zcom.h



Compilation
------------

Normal example
  icc iegsl.c -lgsl -lgslcblas && ./a.out -D 20 --corr -n 64 -R 67 -M 32768

For a large M with limited memory,
   or if you need to use long double
   or __float128 to handle large numbers,
   use "slowdht"
  icc -DSLOWDHT iegsl.c -lgsl && ./a.out -D 20 --corr -n 64 -R 67 -M 32768

In practice, we *always* use slowdht, for it is more flexible.

For slowdht with long double, define LDBL or LONG in compilation
  icc -DLDBL -DSLOWDHT iegsl.c -lgsl -lgslcblas

For slowdht with __float128, define F128 or QUAD in compilation
  gcc -DF128 -DSLOWDHT -Wall -Wextra iegsl.c -lgsl -lgslcblas -lquadmath
Note to use `gcc' instead of `icc' in this case.



Options
--------
  -D30          specifiy the dimension as 30

  -n128         specifiy the maximal order as 128

  -M8192        specify 8192 evaluation points along r

  --disk=2      use disk-based discrete Hankel transform

  --hnc         do the HNC closure instead of the PY one
                the latter is the default

  --corr        do the self-consistent closure



Precision
----------

Tested for dimensions 2 - 30.

Generally, we need more precise data type for higher dimensional cases.

The following examples may help the user to choose the proper parameters

For D = 30, n = 128, M = 3072 (sampling points)

  PY:   __float128 and long double make no difference
        up to 14 significant digits.

        For B(128):
                              Bc                    Bv
          long double:     -1.65055622495195e7    -1.12865683738071e8
          __float128:      -1.65055622495195e7    -1.12865683738071e8
        So there is a 20% difference in Bc.

        By comparison, with -M2048, B(128) are given below
                              Bc                    Bv
          long double:     -3.14733368059798e1    -2.34259117610089e3
          __float128:      -3.14733368059798e1    -2.34259117610089e3

        However, the __float128 version is 12 times
        as slow as the long double version.
        (1400s vs 115s, disk-based, no matrix time, T60).

  HNC:  The __float128 and long double versions make
        no difference in Bv, but significant difference in Bc
        For B(128):
                              Bc          Bv
          long double:     -8.0428e7    -1.11432807771606e8
          __float128:      -1.0507e7    -1.11432807771606e8
        So there is a 20% difference in Bc.

        By comparison, with -M2048, B(128) are given below
                              Bc          Bv
          long double:     -1.508e3     -2.31117866186384e3
          __float128:      -2.004e3     -2.31117866186384e3

        The __float128 version is much slower than
        the long double version.
        (1502 vs 61s, disk-based, no matrix time, T60)

  SC:   SC stands for the Self-Consistent closure.
        The __float128 version gives more accurate results
        than long double version.
        For B(128):
          long double:    -1.1138e+8
          __float128:     -1.1154e+8
        So the difference is 0.15%.

        By comparison, with -M2048, B(128) are given below
          long double:    -2.3072e+3
          __float128:     -2.3108e+3
        So the difference is also about 0.15%.

        Note that the figure themselves are very wrong,
          the correct figure from -M65536 (long double) is -6.8e11.
        Thus the bin-size dependence is much larger than
          the dependence on the float-point precision.

        The __float128 version is much slower than
        the long double version.
        (1497 vs 61s, disk-based, no matrix time, T60)





ieodfftw
=========

Compilation
-----------

  gcc -DF128 ieodfftw.c -lfftw3q -lquadmath -lm && ./a.out -D 15 -n 64 -R 66.01 -M 262144 --corr





ieodmpfr
=========

Compilation
------------

When ieodfftw fails, switch to the mpfr version to enable higher precisions.

  icc ieodmpfr.c -lmpfr -lgmp && ./a.out -D 15 -n 128 -R 131.072 -M 262144 --corr

Note, FFTW is unavailable in this case, and we use fftmpfr.h in this case.

