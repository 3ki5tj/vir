Compute virial coefficients from integral equations



Summary of programs
====================


"~" means non-essential files

C programs (native datatypes family)
-------------------------------------
    ievir.c         GSL/FFTW3   compute virial coefficients of integral equations
                                actual code of iegsl.c and ieodfftw.c

    iegsl.c         GSL         alias of ievir.c as a symbolic link
                    slowdht.h   an arbitrary even or odd dimension

    ieodfftw.c      FFTW3       alias of ievir.c as a symbolic link
                    fft.h       arbitrary odd-dimensional case

    snapfixgsl.c    GSL         fix the snapshotXXX_.dat output of iegsl.c
    (deprecated)                e.g., the snapshotXXX_ck.dat and snapshotXXX_tr.dat
                                may be of a different frame.

    ozcrtr.c        GSL/FFTW3   given c(r), compute t(r) from the OZ relation

    ljievir.c       GSL/FFTW3   for the LJ potential

    ieutil.h        none        common routines for the above programs

    xdouble.h       none        defines the datatype xdouble, which can be
                                double, long double or __float128.

    slowdht.h       GSL         discrete Hankel transform
                                (supports xdouble.h)

 ~  fft.h           none        home-made code for FFT
                                (supports xdouble.h, used as a reference)

    ie.c            none        integral equation solver


C programs (MPFR family)
-------------------------
    ieodmpfr.c      MPFR        generalized odd-dimensional case

    ieutilmpfr.h    MPFR        common routines for the MPFR programs
                                the counterpart of ieutil.h

    fftmpfr.h       MPFR        multiple-precision code for FFT
                                the counterpart of fft.h

C programs (common)
--------------------
    zcom.h          none        common routines


Python script
--------------
    ievirextra.py               extrapolation script

    ieoptparam.py               script to find optimal parameters

    scifmt.py                   format a number with error in parentheses
                                used in ievirextra.py




See bak/README for additional code.
ie3dxxx.c is kept along with ieodxxx.c for the purpose of double checking.




iegsl
======

Overview
---------

  o compute virial coefficients from a specific closure

  o works for any dimensions, but best for even dimensions
    for odd dimensions, use ieodfftw or ieodmpfr instead.

  o supports the following closures
     Percus-Yevick (PY)
     hypernetted-chain (HNC)
     Rowlinson, t(r) = (y(r) - 1) (1 - phi) + phi ln y(r)
     inverse Rowlinson (IR), y(r) = exp(t(r)) phi + (1 - phi) (1 + t(r))
     Hurst, t(r) = y(r)^m log y(r)
     Hutchinson-Conkie (HC)
     Verlet (VM)
     Rogers-Young (RY)
     Marucho-Pettitt (MP)
     term-by-term self-consistent (based on inverse-Rowlinson)

  o uses the discrete Hankel transform (based on the routine in the GSL library,
    but modified in slowdht.h)

  o supports double/long double/__float128 as the basic data type.

  o slowdht.h permits disk-based Hankel transformation
    of many evaluation points

  o supports check points, (with option "-s")
    which allows a restartable run.



Source code
------------
  o iegsl.c
  o slowdht.h
  o xdouble.h
  o zcom.h



Compilation
------------

Normal example
  icc iegsl.c -lgsl -lgslcblas && ./a.out -D 20 --corr -n 64 -R 67 -M 32768

For a large M with limited memory,
   or if you need to use long double
   or __float128 to handle large numbers,
   use "slowdht"
  icc -DSLOWDHT iegsl.c -lgsl && ./a.out -D 20 --corr -n 64 -R 67 -M 32768

In practice, we *always* use slowdht, for it is more flexible.

For slowdht with long double, define LDBL or LONG in compilation
  icc -DLDBL -DSLOWDHT iegsl.c -lgsl -lgslcblas

For slowdht with __float128, define F128 or QUAD in compilation
  gcc -DF128 -DSLOWDHT -Wall -Wextra iegsl.c -lgsl -lgslcblas -lquadmath
Note to use `gcc' instead of `icc' in this case.



Options
--------
  -D30          specifiy the dimension as 30

  -n128         specifiy the maximal order as 128

  -M8192        specify 8192 evaluation points along r

  --disk=2      use disk-based discrete Hankel transform

  --hnc         do the HNC closure instead of the PY one
                the latter is the default

  --corr        do the self-consistent closure



Precision
----------

Tested for dimensions 2 - 30.

Generally, we need more precise data type for higher dimensional cases.

The following examples may help the user to choose the proper parameters

For D = 30, n = 128, M = 3072 (sampling points)

  PY:   __float128 and long double make no difference
        up to 14 significant digits.

        For B(128):
                              Bc                    Bv
          long double:     -1.65055622495195e7    -1.12865683738071e8
          __float128:      -1.65055622495195e7    -1.12865683738071e8
        So there is a 20% difference in Bc.

        By comparison, with -M2048, B(128) are given below
                              Bc                    Bv
          long double:     -3.14733368059798e1    -2.34259117610089e3
          __float128:      -3.14733368059798e1    -2.34259117610089e3

        However, the __float128 version is 12 times
        as slow as the long double version.
        (1400s vs 115s, disk-based, no matrix time, T60).

  HNC:  The __float128 and long double versions make
        no difference in Bv, but significant difference in Bc
        For B(128):
                              Bc          Bv
          long double:     -8.0428e7    -1.11432807771606e8
          __float128:      -1.0507e7    -1.11432807771606e8
        So there is a 20% difference in Bc.

        By comparison, with -M2048, B(128) are given below
                              Bc          Bv
          long double:     -1.508e3     -2.31117866186384e3
          __float128:      -2.004e3     -2.31117866186384e3

        The __float128 version is much slower than
        the long double version.
        (1502 vs 61s, disk-based, no matrix time, T60)

  SC:   SC stands for the Self-Consistent closure.
        The __float128 version gives more accurate results
        than long double version.
        For B(128):
          long double:    -1.1138e+8
          __float128:     -1.1154e+8
        So the difference is 0.142%.

        By comparison, with -M2048, B(128) are given below
          long double:    -2.3072e+3
          __float128:     -2.3105e+3
        So the difference is also about 0.157%.
        It is possible that the difference diminishes with
        the number of evaluation points.

        Note that the figure themselves are very wrong,
          the correct figure from -M65536 (long double) is -6.8e11.
        Thus the bin-size dependence is much larger than
          the dependence on the float-point precision.

        The __float128 version is much slower than
        the long double version.
        (1497 vs 61s, disk-based, no matrix time, T60)

        Precision of using long double and double
        -M4096 -n128 compared with __float128
        see data/iebenchmark
        --------------------------------------
            D       long double       double
            2         4.76e-7         2.53e-5
                      8.88e-16        2.75e-10  (-n32)
            4         1.04e-4         7.36e-2
                      2.97e-11        5.15e-14  (-n16)
            6         2.22e-16        9.73e-14
                      0               1.58e-14  (-n64)
            8         0               1.09e-13
            10        3.55e-15        3.62e-12
            12        8.04e-14        8.31e-11
            14        2.28e-13        1.15e-8
            16        1.81e-10        2.87e-7
            18        4.02e-9         2.46e-6
            20        7.64e-8         5.71e-5
            22        1.29e-6         1.75e-3
            24        1.97e-5         underflow
            26        7.53e-5         underflow
            28        5.30e-4         underflow
            30        1.26e-3         underflow



ieodfftw
=========

Overview
---------
Similar to iegsl, but specialized for odd dimensions.


Compilation
-----------

  gcc -DF128 ieodfftw.c -lfftw3q -lquadmath -lm && ./a.out -D 15 -n 64 -R 66.01 -M 262144 --corr





ieodmpfr
=========

Overview
---------
High precision version of ieodfftw,
currently with limited features.


Compilation
------------

When ieodfftw fails, switch to the mpfr version to enable higher precisions.

  icc ieodmpfr.c -lmpfr -lgmp && ./a.out -D 15 -n 128 -R 131.072 -M 262144 --corr

Note, FFTW is unavailable in this case, and we use fftmpfr.h in this case.

