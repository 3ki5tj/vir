%\documentclass{revtex4-1}
% options: aip, jcp, reprint, preprint
\documentclass[aip,jcp,reprint,superscriptaddress]{revtex4-1}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{bm}
\usepackage{tikz}

\newtheorem{defn}{Definition}
\newtheorem{thrm}{Theorem}
\newtheorem{lemm}[thrm]{Lemma}
\newtheorem{prop}[thrm]{Proposition}

\newcommand{\vct}[1]{\mathbf{#1}}
\providecommand{\vr}{} % clear \vr
\renewcommand{\vr}{\vct{r}}
\newcommand{\vk}{\vct{k}}
\newcommand{\dvk}{\frac{d\vk}{(2\pi)^D}}

% add a superscript ``ex''
\newcommand{\supex}[1]{{#1}^{\mathrm{ex}}}
\newcommand{\Pex}{\supex{P}}
\newcommand{\Fex}{\supex{F}}
\newcommand{\muex}{\supex{\mu}}

\newcommand{\secref}[1]{Sec. \ref{#1}}



\begin{document}

\title{Computing virial coefficients from integral equations}

\author{C.-L. Lai}
\author{C. Zhang}
\author{B.M. Pettitt}
\email{mpettitt@utmb.edu}
\affiliation{
  Sealy Center for Structural Biology and Molecular Physics,
  Department of Biochemistry and Molecular Biology, \\
  The University of Texas Medical Branch,
  Galveston, Texas 7755, USA
}

\begin{abstract}
Several dynamic programming techniques were developed
  to compute high-order virial coefficients of simple liquids
  from the integral equations
  of Percus-Yevick (PY) and hypernetted-chain (HNC) approximations.
%
With a simple order-by-order correction,
  the method produced
  good approximations of the virial coefficients in
  high-dimensional hard-sphere liquids.
%
In addition, a graphic method of constructing integrals of
  pressure-related thermodynamic quantities
  is presented.
\end{abstract}
\maketitle






\section{Introduction}

The equation of state of a simple liquid
  can be written as a series expansion of
  the pressure $P$ in terms of the density $\rho$:
%
\begin{equation}
  \beta P = \rho + B_2 \rho^2 + B_3 \rho^3 + \cdots,
\label{eq:virial}
\end{equation}
%
where $\beta = 1/(k_B T)$ is the inverse temperature
 ($k_B$ is the Boltzmann constant).
%
We are interested in computing the virial coefficients $B_n$.


The equation of state is commonly found
  through an integral equation, which
  can be broken into a pair of equations
  regarding the direct correlation function $c(\vr)$
  and the indirect correlation function $t(\vr)$.
%
The first equation is the Ornstein-Zernike relation\cite{hansen},
\begin{equation}
  t(\vr) = \rho [c * (c + t)](\vr),
\label{eq:oz}
\end{equation}
%
where ``$*$'' denotes a convolution of two spatial functions:
\begin{equation*}
  (a * b)(\vr) = \int d\vr' a(\vr - \vr') b(\vr').
\label{eq:convol}
\end{equation*}
%
The second equation is an approximate relation called ``closure.''
%
Here we focus on two common choices,
%
the Percus-Yevick (PY) closure:
%
\begin{equation}
  c(\vr) = f(\vr) [1 + t(\vr)],
  \label{eq:py}
\end{equation}
%
or the hypernetted-chain (HNC) closure
%
\begin{equation}
  c(\vr) = f(\vr) e^{t(\vr)} - t(\vr) - 1,
  \label{eq:hnc}
\end{equation}
%
where
  $f(\vr) = e^{-\beta \phi(\vr)} - 1$,
with $\phi(\vr)$ being the potential.



Our aim is to compute high-order virial coefficients from
  the integral equations.
%
This is done by a power expansion in $\rho$ of both sides
  of \eqref{eq:oz}, \eqref{eq:py} and \eqref{eq:hnc}.
%
An explicit algorithm for the PY closure has already
  been given by Shaul et al.\cite{sspk},
  while that for the HNC closure was less satisfactory,
  owing to an $O(n!)$ running time ($n$ is the order).
%
We will give a polynomial algorithm for the HNC closure
  and some variants by dynamic programing.
%
Further, we give a simple correction to achieve self-consistency,
  which proves to be useful for high-dimensional hard-sphere liquids.
%
We describe the methods in \secref{sec:methods}.





\section{\label{sec:methods}Methods}

Here, we show how to obtain virial coefficients from the integral equations.

\subsection{Thermodynamic quantities and virial coefficients}

The virial coefficients can be derived from
  various thermodynamic quantities,
  which can be the pressure, or its derivatives or integrals,
  or their combinations.
%
Generally, each thermodynamic quantity
  can be written as an integral of $c(\vr)$ and $t(\vr)$,
  and in the Appendices,
  we discuss a graphic method\cite{morita1958, *morita1960, baxterpressure}
  of constructing these integrals.



\tikzstyle{blackdot}=[circle,draw=black,fill=black,
                      inner sep=0pt,minimum size=1.5mm]
\tikzstyle{whitedot}=[circle,draw=black,fill=white,
                      inner sep=0pt,minimum size=1.5mm]



\appendix

\section{Graphic representation of cluster integrals}

white dots

\begin{equation}
  c^{\scriptscriptstyle \mathrm{PY}}(\vr) =
  {
    \begin{tikzpicture}
      \node (r1) at (180 : 0.2) [whitedot]{};
      \node (r2) at (  0 : 0.2) [whitedot]{};
      \draw (r1) -- (r2);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (   0,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r3) -- (r1);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r4) -- (r3) -- (r1);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r4) -- (r3) -- (r1);
      \draw (r1) -- (r4);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r4) -- (r3) -- (r1);
      \draw (r2) -- (r3);
    \end{tikzpicture}
  }
  + \cdots
\label{eq:crpy}
\end{equation}




\begin{equation}
  c^{\scriptscriptstyle \mathrm{HNC}}(\vr) =
  {
    \begin{tikzpicture}
      \node (r1) at (180 : 0.2) [whitedot]{};
      \node (r2) at (  0 : 0.2) [whitedot]{};
      \draw (r1) -- (r2);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (   0,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r3) -- (r1);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r4) -- (r3) -- (r1);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r2) -- (r4) -- (r3) -- (r1) -- (r4);
    \end{tikzpicture}
  }
  +
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r2) -- (r4) -- (r3) -- (r1) -- (r2) -- (r3);
    \end{tikzpicture}
  }
  +\frac{1}{2}
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r3) -- (r2) -- (r4) -- (r1);
    \end{tikzpicture}
  }
  +\frac{1}{2}
  {
    \begin{tikzpicture}[baseline=-0.7mm]
      \node (r1) at (-0.2, -0.2) [whitedot]{};
      \node (r2) at ( 0.2, -0.2) [whitedot]{};
      \node (r3) at (-0.2,  0.2) [blackdot]{};
      \node (r4) at ( 0.2,  0.2) [blackdot]{};
      \draw (r1) -- (r3) -- (r2) -- (r4) -- (r1) -- (r2);
    \end{tikzpicture}
  }
  + \cdots
\label{eq:crhnc}
\end{equation}




\pagebreak



\section{PY approximation and polygon graphs}



We characterize graphs involved in the PY closure
  in terms of a class of planar graphs.
%
We say that a graph $G$ is a \emph{polygon graph}
  if
  %
  1) the vertices of $G$ can be placed
  on a regular polygon inscribed in a circle,
  with no edges intersecting;
  %
  2) all neighboring vertices are adjacent,
  as explained below.
%
If the vertices
  are labelled from 1 to $n$ in a clockwise fashion,
%
then condition 2) means that
  the consecutive vertices
  $1$ and $2$, $2$ and $3$, \ldots,
  or $n$ and $1$ ($\equiv n+1$) are adjacent.
%
If $n = 2$, the graph with a single edge
  is also defined as a polygon graph.
%
Further, we say that a graph is a \emph{pie graph}
  if it differs from a polygon graph
  only by a missing edge between $1$ and $n$.
%
We call the vertices $1$ and $n$ the \emph{roots},
  and draw them as white dots;
  the rest of the vertices are black.
%
Two examples are shown below.
%
\[
  \begin{tikzpicture}
    \node (r1) at (-90+360.0/7*6.5 : 0.5) [whitedot,label=left:\small{$1$}]{};
    \node (r2) at (-90+360.0/7*5.5 : 0.5) [blackdot,label=left:\small{$2$}]{};
    \node (r3) at (-90+360.0/7*4.5 : 0.5) [blackdot,label=left:\small{$3$}]{};
    \node (r4) at (-90+360.0/7*3.5 : 0.5) [blackdot,label=above:\small{}]{};
    \node (r5) at (-90+360.0/7*2.5 : 0.5) [blackdot,label=right:\small{$n-2$}]{};
    \node (r6) at (-90+360.0/7*1.5 : 0.5) [blackdot,label=right:\small{$n-1$}]{};
    \node (r7) at (-90+360.0/7*0.5 : 0.5) [whitedot,label=right:\small{$n$}]{};
    \draw[thick]
          (r1) -- (r2) -- (r3) (r5) -- (r6) -- (r7) -- (r1)
          (r2) -- (r4) (r5) -- (r1) (r5) -- (r7);
    \draw[thick,densely dotted] (r3) -- (r4) -- (r5);
    \node (polygon) at (0, -0.7) [anchor=north] {Polygon graph};
  \end{tikzpicture}
  \;\;\;
  \begin{tikzpicture}
    \node (r1) at (-90+360.0/7*6.5 : 0.5) [whitedot,label=left:\small{$1$}]{};
    \node (r2) at (-90+360.0/7*5.5 : 0.5) [blackdot,label=left:\small{$2$}]{};
    \node (r3) at (-90+360.0/7*4.5 : 0.5) [blackdot,label=left:\small{$3$}]{};
    \node (r4) at (-90+360.0/7*3.5 : 0.5) [blackdot,label=above:\small{}]{};
    \node (r5) at (-90+360.0/7*2.5 : 0.5) [blackdot,label=right:\small{$n-2$}]{};
    \node (r6) at (-90+360.0/7*1.5 : 0.5) [blackdot,label=right:\small{$n-1$}]{};
    \node (r7) at (-90+360.0/7*0.5 : 0.5) [whitedot,label=right:\small{$n$}]{};
    \draw[thick]
          (r4) -- (r1) -- (r2) -- (r3)
          (r5) -- (r6) -- (r7) -- (r1)
          (r6) -- (r4) -- (r7);
    \draw[thick,densely dotted] (r3) -- (r4) -- (r5);
    \node (pie) at (0, -0.7) [anchor=north] {Pie graph};
  \end{tikzpicture}
\]



We will show that $c(\vr)$ gives the sum of all polygon graphs.

By joining two polygon graphs $A$ and $B$ at a root,
  and blackening the merged root,
  we obtain a \emph{concatenation} $A*B$,
  which is numerically equivalent to a convolution.

\begin{lemm}
A pie graph is equivalent to
  a serial concatenation (or a \emph{chain})
  of polygon graphs.
\label{thm:pycat}
\end{lemm}

\begin{proof}
If $G$ is a pie graph,
  and $v$ is the last vertex adjacent to $1$ ($2 \le v < n$),
  then the induced subgraph $G^{(1)} = G(\{1, \dots, v\})$
  is a polygon graph.
%
Now if $v$ and $n$ are adjacent, then
  the induced subgraph $G^{(2)} = (\{v, \dots, n\})$
  is also a polygon graph.
%
Otherwise $G^{(2)}$ is a pie graph
  rooted at $v$ and $n$.
%
We may then recursively apply the above step
  to reduce $G^{(2)}$
  as a serial concatenation of polygon graphs.

For the reverse direction,
  let $G=G^{(1)}*\cdots*G^{(l)}$.
%
We order the vertices as
  $v^{(1)}_1 = 1$,
  $v^{(1)}_2 = 2$,
  \dots,
  $v^{(1)}_{n_1 - 1}$, % = n_1 - 1$,
  %
  $v^{(2)}_1 = v^{(1)}_{n_1}$,
  $v^{(2)}_2$,
  \dots,
  $v^{(2)}_{n_2 - 2}$, % = n_1 + n_2 - 2$,
  %
  \dots,
  $v^{(l)}_{n_l}$,
%
where $v^{(i)}_j$ is the $j$th vertex of $G^{(i)}$,
  such that consecutive vertices are adjacent.
%
It is also clear that there is no intersecting edges.
%
So $G$ is a pie graph.
\end{proof}



\begin{lemm}
A polygon graph of three or more vertices
  is equivalent to
  a circular concatenation (or a \emph{cycle})
  of three or more polygon graphs.
\label{thm:pycatc}
\end{lemm}

\begin{proof}
By removing the edge between the roots,
  we get a pie graph,
  which is a chain of polygon graphs
  by Lemma \ref{thm:pycat}.
%
The chain is closed by the edge between the roots,
  which is also a polygon graph,
  to form a cycle.

For the reverse direction,
  we can order the vertices as in a manner similar to
  that in the proof of Lemma \ref{thm:pycat},
  and show that it produces a polygon graph.
\end{proof}



\begin{lemm}
Under the PY closure,
  $c(\vr)$ is the unweighted sum of
  all polygon graphs,
  and $t(\vr)$ is that of all pie graphs.
\label{thm:pycrsum}
\end{lemm}

\begin{proof}
We prove this by an induction on the number of vertices $n$ in
  graphs included in $c(\vr)$ or $t(\vr)$.
%
The statement obviously holds for $n \le 3$.
%
Suppose it remains so for $n \le k$,
consider the case of $n = k + 1$.
%
The Ornstein-Zernike relation
$t = \rho c * c + \rho^2 c * c * c + \cdots$
shows that every $(k+1)$-vertex graph in $t(\vr)$
  is a serial concatenation
  of smaller polygon graphs,
  and hence a pie graph
  by Lemma \ref{thm:pycat}.

Then, by the PY closure
$c(\vr) = f(\vr) + f(\vr) \, t(\vr)$,
a $(k+1)$-vertex graph in $c(\vr)$
  differs from some $(k+1)$-vertex graph in $t(\vr)$
  by the edge between the roots only,
  and hence is a polygon graph.
%
So the statement holds for $k+1$,
  hence for any $n$.
\end{proof}




We now consider graphs represented by
  $X = \rho^2 \int c(\vr) \, d\vr$.
%
For any polygon graph $G$,
  the integration $\rho \int d\vr$ removes
  the identity of one root,
  whereas the choice of the other root
  does not alter the value of the integral $I(G)$
  (it changes only the origin of the integration).
%
Thus, we may draw all vertices in a graph in $X$
  as black dots of weight $\rho$,
  bearing in mind that one of the black dots
  is not to be integrated over.
%
We call such a graph $G$ an \emph{unrooted} polygon graph.
%
Since there are precisely $2n$ ways ($n$ is the number of vertices) of
  choosing an ordered pair of consecutive vertices as the roots,
  each $G$ occurs $2n/s$ times in $X$,
  where $s$ is the symmetry number, or
  the number of ways of relabelling the
  vertices to produce the same graph
  (i.e., $s$ is the size of the automorphism group of $G$).
%
For example,
%
%
% Examples of the symmetry numbers
%
%
\newcommand{\hh}{0.07}
\begin{equation*}
  s \left( {
    \begin{tikzpicture}[baseline=-1mm]
      \node (r1) at (-4*\hh, -4*\hh) [blackdot]{};
      \node (r2) at ( 4*\hh, -4*\hh) [blackdot]{};
      \node (r3) at ( 4*\hh,  4*\hh) [blackdot]{};
      \node (r4) at (-4*\hh,  4*\hh) [blackdot]{};
      \draw (r1) -- (r2) -- (r3) -- (r4) -- (r1);
    \end{tikzpicture}
    } \right)
  = 8,
  \;\;
  s \left( {
    \begin{tikzpicture}[baseline=-1mm]
      \node (r1) at (-2.3*\hh, -4*\hh) [blackdot]{};
      \node (r2) at (-4.6*\hh,  0.0) [blackdot]{};
      \node (r3) at (-2.3*\hh,  4*\hh) [blackdot]{};
      \node (r4) at ( 2.3*\hh,  4*\hh) [blackdot]{};
      \node (r5) at ( 4.6*\hh,  0.0) [blackdot]{};
      \node (r6) at ( 2.3*\hh, -4*\hh) [blackdot]{};
      \draw (r1) -- (r2) -- (r3) -- (r4) -- (r5) -- (r6) -- (r1)
            (r1) -- (r5) (r1) -- (r4);
    \end{tikzpicture}
    } \right)
  = 1.
\end{equation*}
%
Note that $s$ always divides $2n$,
  i.e., the only permissible symmetry operations
  are rotations and reflections.
%
This is because to avoid intersecting edges,
  consecutive vertices must be mapped
  to consecutive vertices on the circle
  after the relabelling.
%
To summarize
%
%
%
\begin{lemm}
Under the PY-closure,
  $\rho^2 \int c(\vr) d\vr$ is the sum of
  all nonequivalent unrooted polygon graphs $G$ as
  %
  \begin{equation}
      \rho^2 \int c(\vr) d\vr
    = \sum_{G} \frac{ 2 \, n(G) }{ s(G) } I(G).
  \label{eq:pyXsum}
  \end{equation}
  %
  where $n(G)$, $s(G)$ and $I(G)$ are
  the number of vertices,
  the symmetry number,
  and the integral of $G$,
  respectively.
\end{lemm}





\subsection*{Face decomposition}



Recall that Lemma \ref{thm:pycatc} shows that a polygon graph
  can be decomposed to a cycle of polygon graphs.
%
For an unrooted graph, the decomposition is not unique.
%
Geometrically, each cycle corresponds to a face of the polygon,
  as illustrated below.
%
\begin{equation*}
  %
  \newcommand\sz{0.8}
  \newcommand\del{0.1}
  \newcommand\osa{3.5*\sz}
  \newcommand\osb{7*\sz}
  %
  \begin{tikzpicture}
  %
  % part 1
  %
    \node (r1) at (-90+60.0*5.5 : \sz) [blackdot]{};
    \node (r2) at (-90+60.0*4.5 : \sz) [blackdot]{};
    \node (r3) at (-90+60.0*3.5 : \sz) [blackdot]{};
    \node (r4) at (-90+60.0*2.5 : \sz) [blackdot]{};
    \node (r5) at (-90+60.0*1.5 : \sz) [blackdot]{};
    \node (r6) at (-90+60.0*0.5 : \sz) [blackdot]{};
    \draw[thick] (r1) -- (r2) -- (r3) -- (r4) -- (r5) -- (r6) -- (r1);
    \draw[thick] (r2) -- (r4) (r5) -- (r1);
    \draw[red!50,thick] plot [smooth cycle]
      coordinates{(-0.72*\sz, 0.25*\sz) (-0.45*\sz, 0.75*\sz) (0.18*\sz, 0.75*\sz)};
    \draw[blue!70,thick] plot [smooth cycle]
      coordinates{(-0.75*\sz, 0) (-0.4*\sz, -0.65*\sz) (0.75*\sz, 0) (0.4*\sz, 0.65*\sz)};
    \draw[green!50,thick] plot [smooth cycle]
      coordinates{(-0.18*\sz, -0.75*\sz) (0.45*\sz, -0.75*\sz) (0.72*\sz, -0.25*\sz)};
  %
  % part 2
  %
    \node (r1r) at (\osa-0.5*\sz-\del, -0.866*\sz+.4*\del) [whitedot]{};
    \node (r2r) at (\osa-1.0*\sz, -\del) [whitedot]{};
    \draw[thick] (r1r) -- (r2r);

    \node (r4r) at (\osa+0.5*\sz+\del,  0.866*\sz-.4*\del) [whitedot]{};
    \node (r5r) at (\osa+1.0*\sz,  \del) [whitedot]{};
    \draw[thick] (r4r) -- (r5r);

    \node (r2p) at (\osa-1.0*\sz,  \del) [whitedot]{};
    \node (r3p) at (\osa-0.5*\sz,  0.866*\sz) [blackdot]{};
    \node (r4p) at (\osa+0.5*\sz-\del,  0.866*\sz) [whitedot]{};
    \draw[thick] (r2p) -- (r3p) -- (r4p) -- (r2p);

    \node (r5q) at (\osa+1.0*\sz, -\del) [whitedot]{};
    \node (r6q) at (\osa+0.5*\sz, -0.866*\sz) [blackdot]{};
    \node (r1q) at (\osa-0.5*\sz+\del, -0.866*\sz) [whitedot]{};
    \draw[thick] (r5q) -- (r6q) -- (r1q) -- (r5q);

    \draw[->,very thick] (1.2*\sz, 0) to (\osa-1.2*\sz, 0);
  %
  % part 3
  %
    \node (r1u) at (\osb-0.5*\sz-\del, -0.866*\sz+.4*\del) [whitedot]{};
    \node (r2u) at (\osb-1.0*\sz, -\del) [whitedot]{};

    \node (r4u) at (\osb+0.5*\sz+\del,  0.866*\sz-.4*\del) [whitedot]{};
    \node (r5u) at (\osb+1.0*\sz,  \del) [whitedot]{};

    \node (r2v) at (\osb-1.0*\sz,  \del) [whitedot]{};
    \node (r4v) at (\osb+0.5*\sz-\del,  0.866*\sz) [whitedot]{};

    \node (r5v) at (\osb+1.0*\sz, -\del) [whitedot]{};
    \node (r1v) at (\osb-0.5*\sz+\del, -0.866*\sz) [whitedot]{};

    \draw[thick]
      (r1u) -- node[anchor=east] {$c$} (r2u)
      (r2v) -- node[anchor=south]{$c$} (r4v)
      (r4u) -- node[anchor=west] {$c$} (r5u)
      (r5v) -- node[anchor=north]{$c$} (r1v);

    \draw[->,very thick] (\osa+1.2*\sz, 0) to (\osb-1.2*\sz, 0);
  \end{tikzpicture}
  %
\end{equation*}



If $G$ has $m(G)$ faces, we have, by Euler's formula,
%
\begin{equation}
  n(G) = 2 + \sum_{a = 1}^{m(G)} (l_a - 2)
       = 2 + \sum_{l = 3}^\infty (l - 2) \, m_l(G),
\label{eq:pyfacesum}
\end{equation}
%
where $m(G)$ and $m_l(G)$ are
  the number of faces
  and
  the number of faces of $l$ edges
  in $G$, respectively,
%
and $l_a$ is the number of vertices in face $a$.
%
Using \eqref{eq:pyfacesum} in \eqref{eq:pyXsum} yields
%
\begin{equation}
    \rho^2 \int c(\vr) d\vr
  = \sum_G \frac{ 4 \, I(G) }{ s(G) }
  + \sum_{l = 3}^\infty 2 (l - 2) \, C_l,
\label{eq:pyintgcr2sums}
\end{equation}
%
where $C_l$ is the cycle sum defined as
%
\begin{equation*}
  C_l = \sum_G \frac{ m_l(G) }{ s(G) } I(G).
%\label{eq:pycyclesum}
\end{equation*}



In \eqref{eq:pyintgcr2sums}, we have reduced
  parts of the sum over polygon graphs
  to a sum of $C_l$.
%
Below, we will find a few other integrals that can be
  written as sums of $C_l$.
%
First, we construct the explicit integral of $l$-cycle as
%
\begin{align}
            \int \rho^l c^{*l}(\vr) \, d\vr
  &\equiv   \int \rho^l (\underbrace{c*\cdots *c}_{l-1 \mbox{ times}})(\vr)
                        \, c(\vr) \, d\vr
            \notag \\
  &=        \int \rho^l \tilde{c}^l(\vk) \dvk
  =         (2 \, l) \, C_l,
\label{eq:ccyclintg}
\end{align}
%
where the factor $2 \, l$ corresponds to the number of ways
  of cycling and reflecting the elements in the $l$ cycle.
%
We have assumed that $c(\vr)$ is even
  such that the Fourier transform
  $\tilde{c}(\vk) = \int c(\vr) e^{-i \vk \cdot \vr} \, d\vr$
  satisfies
  $\tilde{c}(\vk) = \tilde{c}(-\vk)$.
%


Multiplying \eqref{eq:ccyclintg} with
  $1/l$, $1$, and $l-3$
  and summing over $l$ yields
%
\begin{align}
      \sum_{l=3}^{\infty} 2 \, C_l
  =& -\int \{ \log[ 1 - \rho \tilde{c}(\vk) ]
     + \rho \tilde{c}(\vk) \}\, \dvk
     \notag \\
   & - \frac{\rho^2}{2} \int c^2(\vr) \, d\vr,
\label{eq:Clsum}
\end{align}
%
\begin{equation}
    \sum_{l=3}^{\infty} 2 \, l \, C_l
  = \rho^2 \int t(\vr) c(\vr) \, d\vr,
\label{eq:Clsuml}
\end{equation}
%
and
%
\begin{equation}
    \sum_{l=3}^{\infty} 2 \, l \, (l - 3) \, C_l
  = \rho^2 \int t^2(\vr) \, d\vr,
\label{eq:Clsumll}
\end{equation}
%
Note that \eqref{eq:Clsum}, \eqref{eq:Clsuml}, and \eqref{eq:Clsumll}
  are applicable to any integral equation (not just the PY one).




\subsection*{Thermodynamic quantities}


We now derive Baxter's pressure formula\cite{baxterpressure}.
%
First note that
  the integral $I(G)$ of an envelope $G$ of $n$ vertices
  is proportional to $\rho^{n(G)}$.
%
Then, by integrating \eqref{eq:pyXsum} over $\rho$,
  we get
\[
    \int d\rho \left( \rho \int c(\vr) d\vr \right)
  = \sum_G \frac{ 2 I(G) }{ s(G) },
\]
%
which yields an expression of the pressure, for
%
\begin{equation}
    \rho \int c(\vr) \, d\vr \
  = -\partial (\beta P^{\mathrm{ex}}) / \partial \rho,
\label{eq:crcompr}
\end{equation}
%
where the superscript ``ex'' means to exclude the ideal gas contribution.
%
Using \eqref{eq:Clsum} and \eqref{eq:Clsuml}
  in \eqref{eq:pyintgcr2sums} yields
%
\begin{align}
      -\beta \Pex
  =&  \sum_{G} \frac{ 2 \, I(G) }{ s(G) }
  =   \frac{ \rho^2 }{ 2 }
      \int [c(\vr) - h(\vr) c(\vr)] \, d\vr \notag \\
  &
      -\int \{ \log[1 - \rho \tilde{c}(\vk)] + \rho \tilde{c}(\vk) \} \dvk.
\label{eq:baxterpressure}
\end{align}



By a linear combination of
  \eqref{eq:pyXsum} and \eqref{eq:baxterpressure},
  we get an expression that avoids
  $\rho^2 \int c(\vr) \, d\vr$.
%
\begin{equation}
    \frac{\partial (\beta \Pex/\rho^2) } {\partial (1/\rho^2)}
  = \sum_G \frac{ n(G) - 2 }{ s(G) }
  = \sum_{l = 3}^{\infty} (l - 2) \, C_k
\label{eq:pymixedpressure}
\end{equation}
%



Similarly, we may construct an approximate expression
  by counting the number of intra-face vertex pairs
  $p(G)$, which satisfies
%
\begin{equation}
  p(G)  = 2 + \sum_{l = 3}^\infty m_l(G) \, [l(l-2) - 2],
\label{eq:pyintrafacepairs}
\end{equation}
%
where $l(l-2)$ gives the number of pairs
  in a face of $l$ vertices,
  and the ``$-2$'' offsets the double-counting
  for each edge $\{i, j\}$,
    which contributes two pairs $(i, j)$ and $(j, i)$,
  shared by two adjacent faces.
%
Thus,
%
\begin{align}
            -\frac{\rho^2}{2}
            \frac{\partial^2 ( \beta \Pex ) }
                 {\partial \rho^2}
  &\approx  \sum_G \frac{p(G)}{s(G)}
  =         \frac{\rho^2}{2} \int [c(\vr) + t(\vr) h(\vr) ] \, d\vr
            \notag \\
  &=        \sum_G \frac{2}{s(G)}
            + \sum_{l = 3}^\infty [l(l-1) - 2] C_l.
\label{eq:pyddpressure}
\end{align}
%
This formula is biased, for
  $p(G) \le n(G) [n(G) - 1]$,
but it should be a good approximation
  up to the internal consistency
  of the HNC approximation.





\section{\label{sec:hnc}HNC approximation}



The HNC closure includes
  more graphs than the PY closure.
%
For example, $c(\vr)$ contains
%
\begin{equation}
  \renewcommand{\hh}{0.22cm}
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-2.0*\hh,  2*\hh) [whitedot]{};
    \node (r2) at (   0,      4*\hh) [blackdot]{};
    \node (r5) at (   0,      0*\hh) [blackdot]{};
    \node (r6) at ( 2.0*\hh,  2*\hh) [whitedot]{};
    \draw[thick]
          (r1) -- (r2) -- (r6)
          (r1) -- (r5) -- (r6);
  \end{tikzpicture},
  %
  \;\;
  %
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-2.0*\hh,  1*\hh) [whitedot]{};
    \node (r2) at (   0,      4*\hh) [blackdot]{};
    \node (r3) at (   0,      2*\hh) [blackdot]{};
    \node (r5) at (   0,      0*\hh) [blackdot]{};
    \node (r6) at ( 2.0*\hh,  1*\hh) [whitedot]{};
    \draw[thick]
          (r1) -- (r2) -- (r6)
          (r1) -- (r3) -- (r6)
          (r1) -- (r5) -- (r6);
  \end{tikzpicture},
  %
  \;\;
  %
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-2.0*\hh,  2*\hh) [whitedot]{};
    \node (r2) at (   0,      4*\hh) [blackdot]{};
    \node (r3) at (   0,      3*\hh) [blackdot]{};
    \node (r4) at (   0,      1*\hh) [blackdot]{};
    \node (r5) at (   0,      0*\hh) [blackdot]{};
    \node (r6) at ( 2.0*\hh,  2*\hh) [whitedot]{};
    \draw[thick] (r1) -- (r6)
          (r1) -- (r2) -- (r6)
          (r1) -- (r3) -- (r6)
          (r1) -- (r4) -- (r6)
          (r1) -- (r5) -- (r6);
  \end{tikzpicture},
  %
  \;\;\mbox{and}\;\;
  %
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-1.2*\hh,  0) [whitedot]{};
    \node (r2) at (-2.8*\hh,  2.6*\hh) [blackdot]{};
    \node (r3) at (-1.8*\hh,  2.2*\hh) [blackdot]{};
    \node (r4) at (   0,      4*\hh) [blackdot]{};
    \node (r5) at ( 1.8*\hh,  2.2*\hh) [blackdot]{};
    \node (r6) at ( 2.8*\hh,  2.6*\hh) [blackdot]{};
    \node (r7) at ( 1.2*\hh,  0) [whitedot]{};
    \draw[thick] (r1) -- (r7)
                 (r1) -- (r2) (r1) -- (r3) (r1) -- (r4)
                 (r4) -- (r2) (r4) -- (r3)
                 (r4) -- (r5) (r4) -- (r6)
                 (r7) -- (r5) (r7) -- (r6);
  \end{tikzpicture},
  \label{eq:hnccrex}
\end{equation}
%
%
%
but not
%
%
%
\begin{equation}
  \renewcommand{\hh}{0.22cm}
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-2*\hh,  2*\hh) [whitedot]{};
    \node (r2) at (0*\hh,   0*\hh) [blackdot]{};
    \node (r3) at (0*\hh,   4*\hh) [blackdot]{};
    \node (r4) at ( 2*\hh,  2*\hh) [whitedot]{};
    \draw[thick] (r1) -- (r2) -- (r4) -- (r3) -- (r1)
                 (r2) -- (r3);
  \end{tikzpicture}
  \;\;\mbox{and}\;\;
  \begin{tikzpicture}[baseline=1.2mm]
    \node (r1) at (-2*\hh,  2*\hh) [whitedot]{};
    \node (r2) at (0*\hh,   0*\hh) [blackdot]{};
    \node (r3) at (0*\hh,   4*\hh) [blackdot]{};
    \node (r4) at ( 2*\hh,  2*\hh) [whitedot]{};
    \draw[thick] (r1) -- (r2) -- (r4) -- (r3) -- (r1)
                 (r2) -- (r3) (r1) -- (r4);
  \end{tikzpicture}.
  \label{eq:hnccrexnot}
\end{equation}
%
We use the following recursive definition
  to characterize them.
%
A $c$-graph graph is either
%
1)
a single edge
\begin{tikzpicture}
  \node (r1) at (-3mm, 0) [whitedot]{};
  \node (r2) at ( 3mm, 0) [whitedot]{};
  \draw (r1) -- (r2);
\end{tikzpicture},
or
%
2)
a circular concatenation of three or more
  smaller $c$-graphs,
  with the roots being any two joints
  of the concatenation.
%
One can verify that the above definition
  includes all graphs in \eqref{eq:crhnc} and \eqref{eq:hnccrex},
  but none in \eqref{eq:hnccrexnot}.
%
This definition is analogous to Lemma \ref{thm:pycatc}.


We call a $c$-graph without marked roots an envelope.
%
In an envelope,
  an ordered pair of vertices forms a \emph{pivot}
  if marking them as roots reduces the envelope to a $c$-graph.
%
For example,
  \begin{tikzpicture}[baseline=1.0mm]
    \node (r1) at (-2mm, 0) [blackdot,label=left:{\footnotesize$1$}]{};
    \node (r2) at ( 2mm, 0) [blackdot,label=right:{\footnotesize$2$}]{};
    \node (r3) at ( 2mm, 4mm) [blackdot,label=right:{\footnotesize$3$}]{};
    \node (r4) at (-2mm, 4mm) [blackdot,label=left:{\footnotesize$4$}]{};
    \draw (r1) -- (r2) -- (r3) -- (r4) -- (r1) (r1) -- (r3);
  \end{tikzpicture}
is an envelope,
  $(1, 2)$ and $(1, 3)$ are pivots,
  but $(2, 4)$ is not.

We state without proving\cite{morita1958, *morita1960}.
%
%
\begin{lemm}
Under the HNC closure,
  $\rho^2 \int c(\vr) \, d\vr$ is the sum of all nonequivalent envelopes $G$:
  \begin{equation}
    \rho^2 \int c(\vr) \, d\vr
    = \sum_G \frac{p(G)}{s(G)},
  \end{equation}
where $p(G)$ and $s(G)$ are
  the number of pivots and
  the symmetry number, respectively;
%
%
and $c(\vr)$ is the sum of all nonequivalent $c$-graphs $G'$,
\[
  c(\vr) = \sum_{G'} \frac{1}{s(G')},
\]
where $s(G')$ is the number of ways of relabelling
  \emph{black} vertices that keep $G'$ unchanged.
\end{lemm}




\subsection*{Cycle decomposition}



The $c$-graph, which characterizes $c(\vr)$ in the HNC case,
  is the counterpart of the polygon graph,
  which characterizes $c(\vr)$ in the PY case.
%
By definition, an envelope can be written as
  as a cycle (a circular concatenation) of $c$-graphs,
  and the representation is not unique.
%
In the PY case, each cycle corresponds to a face of the polygon.
%
Below we develop a similar interpretation for the HNC case,
  which helps us to obtain counting formulas analogous to
  \eqref{eq:pyfacesum} and \eqref{eq:pyintrafacepairs}.



First, we define a \emph{loop} as a cycle of $l$ ($l \ge 3$) $c$-graphs
  in which at least $(l-1)$ $c$-graphs are single edges.
%
We now show that
%
\begin{lemm}
At least one cycle of an envelope $G$ of three or more vertices
  is a loop.
\end{lemm}
%
\begin{proof}
%
We prove this by giving an algorithm, \textbf{Algorithm L},
  for finding the loop.
%
By definition,
  $G$ has at least one pivot $(v_1, v_{k})$,
  and can be decomposed to a cycle of $c$-graphs
  $K = v_1 - \cdots - v_k - \cdots - v_l - v_1 (\equiv v_{l+1})$,
  with $v_j$ being the $j$th joint.
%
If $K$ is a loop, we are done.


Otherwise, there is at least one link $v_j - v_{j+1}$ in $K$
  that is not a single edge.
%
Let $G_j$ be the $c$-graph between $v_j - v_{j+1}$,
  then $G_j$ can be decomposed to a cycle $J'$ of $c$-graphs
  passing through $v_j$ and $v_{j+1}$.
%
With $v'_1 \equiv v_j$ and $v'_{k'} \equiv v_{j+1}$,
  we may write
  $J' = v'_1 - v'_2 - \cdots - v'_{k'-1}
      - v'_{k'} - v'_{k'+1} - \cdots
      - v'_{l'} - v'_1 (\equiv v'_{l'+1})$
  (as shown below, blue),
and without loss of generality,
  we may assume $k' \ge 3$
  such that the branch $v'_1, v'_2, \dots, v'_{k'}$
  contains at least three vertices.
%
But $J = v'_1 - v'_{l'} - \cdots - v'_{k'+1} - v'_{k'} (= v_{j+1}) \
       - v_{j+2} - \cdots - v_l - v_1 - \cdots - v_j (=v'_1)$
  is a cycle of $c$-graphs (red),
  and thus can be reduced to a single $c$-graph
  rooted at $v'_1$ and $v'_{k'}$.
%
It follows that $G$ can also be decomposed to a cycle
  $K' = v'_1 - v'_2 - \cdots - v'_{k'} - v'_1$
  (green).

\[
  \newcommand{\sz}{5mm}
  \begin{tikzpicture}
    \node (v1)  at ( 0, 0) [blackdot,label=left:$v_1$]{};
    \node (v2)  at ( 0.2*\sz, 1.5*\sz) [blackdot,label=left:$v_2$]{}
      edge[thick, bend right=10] (v1);
    \node (vj)  at ( 2.0*\sz, 3.5*\sz) [blackdot,label=left:$v_j(v'_1)$]{}
      edge[densely dotted, thick, bend right=15] (v2);
    \node (vkm1) at (10.8*\sz, 1.5*\sz) [blackdot,label=right:$v_{k-1}$]{};
    \node (vj1) at ( 9.0*\sz, 3.5*\sz) [blackdot,label=right:$v_{j+1}(v'_{k'})$]{}
      edge[densely dotted, thick, bend left=15] (vkm1);
    \node (vk)  at (11.0*\sz, 0)       [blackdot,label=right:$v_{k}$]{}
      edge[thick, bend right=10] (vkm1);

    % beginning the inner J' loop
    \node (u2) at ( 3.5*\sz, 6.0*\sz) [blackdot,blue,label=above:$v'_2$]{}
      edge[blue, thick, bend right=30] (vj);
    \node (ukm1) at ( 7.5*\sz, 6.0*\sz) [blackdot,blue,label=above:$v'_{k'-1}$]{}
      edge[blue, thick, bend left=30] (vj1)
      edge[blue, densely dotted, thick, bend right=10] (u2);
    \node (uk1) at ( 7.5*\sz, 1.5*\sz) [blackdot,blue,label=above:$v'_{k'+1}$]{}
      edge[blue, thick, bend right=30] (vj1);
    \node (ul) at  ( 3.5*\sz, 1.5*\sz) [blackdot,blue,label=above:$v'_{l'}$]{}
      edge[blue, thick, bend left=30] (vj)
      edge[blue, densely dotted, thick, bend right=10] (uk1);

    \node (Jp) at ( 9.5*\sz, 5.5*\sz) [blue] {$J'$};
    % end of the inner J' loop

    % beginning of the K' loop
    \draw[green!50!black, thick] plot [smooth cycle]
      coordinates{ ( 2.5*\sz, 3.9*\sz)
                   ( 3.5*\sz, 5.7*\sz)
                   ( 7.5*\sz, 5.7*\sz)
                   ( 8.5*\sz, 3.9*\sz) };

    \node (Kp) at ( 5.5*\sz, 5.0*\sz) [green!50!black] {$K'$};
    % end of the K' loop

    \node (vb)  at ( 5.5*\sz,-2.0*\sz) [blackdot]{};

    \node (vk1) at ( 9.5*\sz,-1.2*\sz) [blackdot,label=below:$v_{k+1}$]{}
      edge[densely dotted, thick, bend left=7] (vb)
      edge[thick, bend right=10] (vk);

    \node (vl)  at ( 1.5*\sz,-1.2*\sz) [blackdot,label=below:$v_{l}$]{}
      edge[densely dotted, thick, bend right=7] (vb)
      edge[thick, bend left=10] (v1);

    \draw[dashed,very thick] (vj) -- (vj1);
    \node (K) at (8.0*\sz, -2.2*\sz) {$K$};

    % beginning of the J loop
    \draw[red!80!black, thick] plot [smooth cycle]
        coordinates{ ( 1.5*\sz, 2.5*\sz)
                     ( 0.7*\sz, 0.2*\sz)
                     ( 3.5*\sz,-1.2*\sz)
                     ( 7.5*\sz,-1.2*\sz)
                     (10.3*\sz, 0.2*\sz)
                     ( 9.5*\sz, 2.5*\sz)
                     ( 8.0*\sz, 1.2*\sz)
                     ( 5.5*\sz, 0.8*\sz)
                     ( 3.0*\sz, 1.2*\sz)
                   };
    \node (J) at ( 5.5*\sz, -0.2*\sz) [red!80!black] {$J$};
    % end of the J loop
  \end{tikzpicture}
\]

Now if every $v'_{j'} - v'_{j'+1}$ ($1 \le j' < k'$) is a single edge,
  then we have found the desired loop.
%
Otherwise, we can repeat the above step on $K'$
  and further decompose a link $v'_{j'} - v'_{j'+1}$
  that is not single edge, into a cycle $J''$.
%
We, however, should not decomposing the link
  $v'_1 - v'_{k'}$ in $K'$ in subsequent steps,
  which falls back to the previous state.
%
This can be avoided by replacing
  the $c$-graph between $v'_1$ and $v'_{k'}$
  by a single edge
  in the rest of the search.
%
One can readily show that
  such a replacement removes more edges than vertices.
%
Thus, the process always ends with a loop
  with equal numbers of vertices and edges.
\end{proof}



The algorithm in above proof allows us to
  find all cycles using the algorithm below.

\textbf{Algorithm D:}
\begin{enumerate}
  \item
    Given an envelope $G$,
      repeat steps 2 and 3 until $G$ is a single edge.
  \item
    First, we find a loop in $G$,
      $v_1 - v_2 - \cdots - v_l - v_1$
      using Algorithm L,
      with all $(v_j, v_{j+1})$ $(1 \le j < l)$
      being single edges.
  \item
    We then remove the vertices $v_2, v_3, \dots, v_{l-1}$,
      and join $v_1$ and $v_l$ if they are not adjacent.
\end{enumerate}
%
It is readily shown that,
  Step 3 results in a new envelope $G$
  with $(l - 2)$ fewer vertices,
  and it always ends up with a single edge.
%
One can further show that every cycle in $G$
  corresponds to a loop in the above procedure.
%
Thus,

\begin{lemm}
  An envelope $G$ can be reduced
    by Algorithm D to a single edge in $m(G)$ steps,
    where $m(G)$ is the number of ways of decomposing
    $G$ as a cycle of $c$-graphs.
\label{thm:hncdecomp}
\end{lemm}



\subsection*{Counting formulas}


Lemma \ref{thm:hncdecomp} allows us to develop a few counting formulas.
%
First, since each step of Algorithm L removes $(l - 2)$ vertices,
  with $l$ being the loop length,
  the total number of vertices $n(G)$ is given by
%
\begin{align}
  n(G) &= 2 + \sum_{l = 3}^\infty (l - 2) \, m_l(G),
\label{eq:hnccountn}
\end{align}
%
which is the counterpart of \eqref{eq:pyfacesum}.

A cycle of length $l$, by definition,
  contains $l (l - 1)$ pivots,
  and Step 3 of Algorithm D
  removes all but two of them.
%
Thus
%
\begin{align}
  p(G) = 2 + \sum_{l = 3}^\infty (l-2)(l+1) \, m_l(G),
\label{eq:hnccountp}
\end{align}
%
which is the counterpart of \eqref{eq:pyintrafacepairs}.




\subsection*{Thermodynamic quantities}



%From \eqref{eq:hnccountn}
%and \eqref{eq:Clsuml}

%
\begin{align}
      -2\beta \Fex
  &=  \sum_G \frac{ 2 I(G) } { s(G) }
\label{eq:hncF}
\end{align}

%
\begin{align}
      -\rho \beta \mu
  &=  \sum_G \frac{ n(G) } { s(G) } I(G)
      \notag \\
  &=  \sum_G \frac{ 2 I(G) } { s(G) }
    + \sum_{l = 3}^\infty (l - 2) \, C_l.
\label{eq:hncmu}
\end{align}


%
\begin{align}
      \rho^2 \int c(\vr) \, d\vr
  &=  \sum_G \frac{ p(G) } { s(G) } I(G)
      \notag \\
  &=  \sum_G \frac{ 2 I(G) } { s(G) }
    + \sum_{l = 3}^\infty (l - 2) (l+1) \, C_l.
\label{eq:hncdmu}
\end{align}

Chemical potential:
%
\begin{align}
      \beta \rho \mu
  &= - \rho^2 \int c(\vr) \, d\vr
     + \sum_{l = 3}^\infty (l - 2) \, l \, C_l \\
  &= \rho^2 \int [-c(\vr) + \tfrac{1}{2} t(r) \, h(r)] \, d\vr
\label{eq:hncdmu}
\end{align}





\bibliography{ie}
\end{document}

